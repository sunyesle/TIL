# 프로세스 시스템 콜
## fork()
프로세스가 자기 자신을 복제하는 시스템 콜이다.<br>
`fork()`를 호출하는 프로세스를 부모 프로세스, 새롭게 생기는 프로세스를 자식 프로세스라고 한다.

### fork()의 용도
- 하나의 프로그램에서 새로운 제어 흐름을 만드는 용도
- 다른 프로그램을 실행하는 새 프로세스를 만드는 용도

### fork()로 생성된 자식 프로세스의 특징
- 자식 프로세스는 고유한 프로세스 ID를 갖는다.
- 자식 프로세스는 고유의 메모리 공간을 갖는다.
- 자식 프로세스는 부모 프로세스의 파일 디스크립터 복사본을 갖는다. 부모와 자식 프로세스의 파일 디스크립터는 같은 파일을 가르킨다.

### fork()의 리턴값
- **부모 프로세스**: 자식 프로세스의 PID (양수)
- **자식 프로세스**: 0
- **에러**: -1

<br>

코드를 보며 `fork()` 함수에 대해 알아보자.
```c
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

int main(int argc, const char * argv[]) {
    int pid;
    int x = 1;

    pid = fork();
    if (pid == -1) {
        // possible errors: EAGAIN, ENOMEM.
        perror("Failed to fork");
        return -1;
    }

    if (pid == 0) {
        // child
        printf("child: x=%d\n", ++x);
    } else {
        // parent
        printf("parent: x=%d\n", --x);
    }

    return 0;
}
```
`fork()` 후 각각 자식/부모 프로세스에서 자신의 프로세스 ID를 출력하는 코드다.


<img width="600" alt="fork_1" src="https://github.com/user-attachments/assets/f162e25e-c84c-4cb1-aee7-1e22e10d9aa7" />

출력 결과는 다음과 같다.
```log
child: x=2
parent: x=0
```


자식 프로세스가 생성되면서 Stack, Heap, Data 영역뿐만 아니라,<br>
부모 프로세스의 PCB 정보를 일부 복사하여 새로운 PCB를 만들게 된다.<br>
이때 PC(Program Counter)값 역시 복사해 오기 때문에 자식 프로세스의 실행이 `fork()` 다음부터 시작되는 것이다.

---
**Reference**<br>
- https://blog.potados.com/dev/things-happend-after-fork/
- https://wslog.dev/fork-exec
- https://spongecake.tistory.com/85
- https://rannnneey.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9Cfork-exec-wait-exit-IPCInter-Process-Commuication
- https://velog.io/@xogml951/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Operating-System-Concepts-4-Process-%EC%83%9D%EC%84%B1fork%EA%B3%BC-%EC%86%8C%EB%A9%B8
- https://kylo8.tistory.com/entry/OS-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1%EA%B3%BC-%EB%B3%B5%EC%82%AC-fork-exec-%EC%8B%9C%EC%8A%A4%ED%85%9C%ED%98%B8%EC%B6%9C

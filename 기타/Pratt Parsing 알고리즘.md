# Pratt Parsing 알고리즘
## 파싱이란?
**파싱**은 일련의 문자열을 의미 있는 토큰으로 분해하고(lexing),
이 토큰들로 **파스 트리**(**parse tree**)**를 만드는 과정**(parsing)을 말한다.

`1 + 2 * 4` 라는 수식을 파싱하는 상황을 예로 들어보자.
수식으로부터 다음과 같은 트리를 만들어내야 한다.
```
                    +
                   / \
1 + 2 * 4   ->    1   *
                     / \
                    2   4
```

## 프랫 파싱 (Pratt Parsing)
**프랫 파싱**(Pratt Parsing)은 **하향식 파싱**(top-down) 알고리즘의 한 종류로,
각 토큰이 가진 **결합력**을 기준으로 어떻게 트리를 구성해야 하는지 결정한다.

연산자 우선순위와 결합규칙을 매우 단순한 방식으로 처리할 수 있는 파싱 기법이다.

## 결합력 (Binding Power)
프랫 파싱의 핵심 개념은 **결합력**이다.
결합력은 연산자가 좌우 피연산자를 얼마나 강하게 묶는가를 나타내는 숫자이며,
연산자 우선순위와 결합규칙(좌결합/우결합)을 모두 표현할 수 있다.

**- 연산자 우선순위**

`1 + 2 * 4`에서 `+`보다 `*`가 먼저 계산되는 것은 `*`의 결합력이 더 높기 때문이다.

**- 결합규칙**<br>
- **좌결합**: `+`는 좌측부터 계산된다. `1 + 2 + 4` → `(1 + 2) + 4`
- **우결합**: `^`(거듭제곱)는 우측부터 계산된다. `2 ^ 3 ^ 4` → `2 ^ (3 ^ 4)`

이를 표현하기 위해 왼쪽과 오른쪽의 결합력을 다르게 설정할 수 있다.

### 예시 1: 좌결합 처리
`+`는 왼쪽부터 차례대로 계산되므로 오른쪽의 피연산자가 먼저 붙을 수 있도록 오른쪽의 결합력을 높게 정의한다.
- `+`: (1, 2)
```
1     +     3     +     5
  (1)   (2)   (1)   (2)
```
항상 왼쪽부터 묶여서, `(1 + 3) + 5` 형태로 트리가 만들어지게 된다.

### 예시 2: 연산자 우선순위 처리
`+`보다 `*`가 먼저 묶이도록 결합력를 다음과 같이 정의할 수 있다.
- `+`: (1, 2)
- `*`: (3, 4) ← *더 높은 우선순위*
```
1     +     2     *     4
  (1)   (2)   (3)   (4)
```
`2`가 `*`쪽으로 묶여서, `1 + (2 * 4)` 형태로 트리가 만들어지게 된다.

## 핵심 로직
프랫 파서의 파싱 로직을 단순하게 표현한 예이다.
```java
Lexer lexer = new Lexer("1 + 2 * 4");

Expr parseExpr(int minBp) { // minBp = 현재 토큰 왼쪽에 있는 연산자의 결합력
    Expr lhs = new Expr.Atom(lexer.next()); // 현재 토큰(숫자)을 가져와서, 숫자 노드 생성
    while (true) {
        Token opToken = lexer.peek(); // 다음 토큰(연산자)을 확인한다.
        if(opToken.type == TokenType.EOF) break; // 수식의 끝이면 break

        // 다음 연산자의 결합력을 가져온다.
        int[] bp = BindingPower.infixBindingPower(opToken.value);
        int lBp = bp[0]; // 왼쪽 결합력
        int rBp = bp[1]; // 오른쪽 결합력
        
        // 다음 연산자의 결합력이 minBp보다 낮으면 break
        if (lBp < minBp) break;
        
        lexer.next(); // 토큰 소비 (다음 재귀 호출에서 숫자를 가져올 수 있도록)
        Expr rhs = parseExpr(rBp); // 재귀 호출하여 오른쪽 피연산자 파싱
        
        lhs = new Expr.Operation(opToken.value, List.of(lhs, rhs)); // 연산 노드 생성
    }
    return lhs;
}
```
여기서 `Lexer`는 수식을 읽어서 토큰 단위로 분리해 주는 역할을 한다.
- `peek()`: 다음 토큰지 뭔지 보기만 하고, 위치는 변화시키지 않는다.
- `next()`: 현재 위치의 토큰을 반환하고, 위치를 1 증가시킨다.

### parseExpr()의 동작
`parseExpr()` 메서드는 다음과 같이 동작한다.
1. 좌항(lhs)을 먼저 읽는다. (숫자)
2. 다음 연산자를 확인하고, 해당 연산자의 결합력을 가져온다.
3. lBp < minBp이면
   - 이전 연산자보다 결합력이 낮은 연산자이므로 더 이상 파싱하지 않고 lhs(숫자)를 반환한다.
4. 그렇지 않다면
   - 연산자 토큰을 소비하고, 재귀 호출하여 우항(rhs)을 파싱한다.
5. lhs와 rhs를 결합하여 연산 노드를 생성하고 반환한다.
6. 더 이상의 연산자가 없으면 최종적으로 완성된 lhs를 반환한다.

즉, **우선순위가 높은 것부터 안쪽에서 먼저 파싱**되는 구조다.

## 파싱 과정 예시

`1 + 2 * 4`가 파싱되는 과정을 단계적으로 따라가보자.

**parseExpr(0)**<br>
피연산자와 연산자를 한개씩 가져온다.<br>
`+` 연산자의 lBp(1)가 minBp(0)보다 크다. 1을 lhs으로 두고 rhs을 구하기 위해 재귀호출 한다.
```
  +
 / \
1  rhs
```

**parseExpr(2)**<br>
`*` 연산자의 lBp(3)가 minBp(2)보다 크다. 2를 lhs로 두고 rhs을 구하기 위해 재귀호출 한다.
```
  *
 / \
2  rhs
```

**parseExpr(4)**<br>
더 이상의 토큰이 없으므로(eof) lhs인 4를 반환한다.
```
  4
```


**parseExpr(2)**<br>
rhs로 4를 반환받았다. 연산 노드를 생성하여 반환한다.
```
  *
 / \
2   4
```

**parseExpr(0)**<br>
rhs로 노드를 반환받았다. 최종적으로 완성된 노드를 반환한다.
```
  +
 / \
1   *
   / \
  2   4
```

---
**Reference**
- https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html
- https://www.youtube.com/watch?v=0c8b7YfsBKs


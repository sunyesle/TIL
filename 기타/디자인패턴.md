# 디자인 패턴

### 프록시 패턴
대리자(proxy) 객체를 통해 실제 객체에 대한 접근을 제한한다. 비즈니스 로직이 담긴 클래스를 수정하지 않고도 권한 체크, 지연 로딩(Lazy Loading), 캐싱 처리 등의 작업을 추가할 수 있다.

### 방문자 패턴
방문자가 방문했을 때의 행동을 방문자에게 위임한다. 복합 객체 구조 또는 이질적인 객체들의 집합에서 객체들에 새로운 동작을 추가하고자 할 때 유용하다.

### 전략 패턴
알고리즘 계열(알고리즘군)을 정의하고, 각 알고리즘을 캡슐화하여 상호교환 가능하게 하는 디자인패턴이다. 클라이언트 코드에 영향을 주지 않고 알고리즘을 변경할 수 있다.

### 템플릿 메서드 패턴
슈퍼클래스에서 알고리즘의 뼈대를 정의하고, 서브클래스에서 알고리즘의 구조는 유지한 채 알고리즘의 각 단계를 재정의할 수 있도록 하는 디자인 패턴이다.

### 상태 패턴
객체 내부의 상태가 바뀔 때마다 객체의 행동이 변경되도록 하는 디지인 패턴이다. 각 상태를 별도의 클래스로 추출하고 상태에 대한 적절한 동작을 정의한다.

### 책임 연쇄 패턴
핸들러 체인을 따라 요청을 전달할 수 있도록 하는 디자인 패턴이다. 요청은 처리할 핸들러를 만나거나 체인의 끝에 도착할 때까지 핸들러에서 다른 핸들러로 전달된다.

### 커맨드 패턴
요청에 따른 작업을 객체로 캡슐화하는 디자인 패턴이다. 요청을 호출하는 클래스와 요청을 수행하는 클래스를 분리할 수 있다.

---
### Reference

https://refactoring.guru/ko/design-patterns/catalog

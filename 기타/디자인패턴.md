# 디자인 패턴

### 프록시 패턴
대리자(proxy) 객체를 통해 실제 객체에 대한 접근을 제한한다. 비즈니스 로직이 담긴 클래스를 수정하지 않고도 권한 체크, 지연 로딩(Lazy Loading), 캐싱 처리 등의 작업을 추가할 수 있다.

### 방문자 패턴
방문자가 방문했을 때의 행동을 방문자에게 위임한다. 복합 객체 구조 또는 이질적인 객체들의 집합에서 객체들에 새로운 동작을 추가하고자 할 때 유용하다.

### 전략 패턴
알고리즘 계열(알고리즘군)을 정의하고, 각 알고리즘을 캡슐화하여 상호교환 가능하게 하는 디자인패턴이다. 클라이언트 코드에 영향을 주지 않고 알고리즘을 변경할 수 있다.

### 템플릿 메서드 패턴
슈퍼클래스에서 알고리즘의 뼈대를 정의하고, 서브클래스에서 알고리즘의 구조는 유지한 채 알고리즘의 각 단계를 재정의할 수 있도록 하는 디자인 패턴이다.

### 상태 패턴
객체 내부의 상태가 바뀔 때마다 객체의 행동이 변경되도록 하는 디지인 패턴이다. 각 상태를 별도의 클래스로 추출하고 상태에 대한 적절한 동작을 정의한다.

### 책임 연쇄 패턴
핸들러 체인을 따라 요청을 전달할 수 있도록 하는 디자인 패턴이다. 요청은 처리할 핸들러를 만나거나 체인의 끝에 도착할 때까지 핸들러에서 다른 핸들러로 전달된다.

### 커맨드 패턴
요청에 따른 작업을 객체로 캡슐화하는 디자인 패턴이다. 요청을 호출하는 클래스와 요청을 수행하는 클래스를 분리할 수 있다.

### 반복자 패턴
순회 알고리즘을 별도의 클래스로 분리하여, 컬렉션의 내부 구조(List, Stack, Tree...)와 상관없이 일관된 방식으로 요소들을 접근하고 순회하는 방법을 제공하는 디자인 패턴이다.

### 메멘토 패턴
객체의 상태 저장과 복구 책임을 별도의 클래스로 분리하여, 객체의 내부 구현 사항을 외부에 공개하지 않으면서 객체의 상태를 저장하고 복구 할 수 있도록 하는 디자인 패턴이다.

### 옵저버 패턴
객체의 상태변화를 관찰하고있는 옵저버들에게 객체가 직접 상태변화를 통지하도록하는 디자인패턴이다. 옵저버들은 관찰 대상인 객체가 발생시키는 이벤트를 받아 처리한다.

### 중재자 패턴
중재자 패턴은 객체들 간의 상호작용을 캡슐화하여 하나의 클래스에 위임하여 처리하는 디자인 패턴이다. 각 객체들간의 직접통신 대신 중재자 클래스를 통한 간접통신을 한다. 객체들간의 결합도를 낮출 수 있다.

---
### Reference

https://refactoring.guru/ko/design-patterns/catalog

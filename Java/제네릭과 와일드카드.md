# 제네릭과 와일드 카드
## 변성 (Variance)
제네릭에 대해 알아보기에 앞서 변성의 개념부터 살펴보자.

**변성**이란 제네릭의 **형식 매개변수**가 **클래스 계층**과 어떤 **관계**를 맺는지를 설명하는 개념이다.

변성은 크게 세 가지 종류가 있다.
- **공변**: `S`가 `T`의 하위 타입일 때, `I<S>`는 `I<T>`의 하위타입이다.
- **반공변**: `S`가 `T`의 하위 타입일 때, `I<S>`는 `I<T>`의 상위타입이다.
- **불공변**: `S`가 `T`의 하위 타입일 때, `I<S>`와 `I<T>`사이에 어떠한 상속관계도 없다.

## 제네릭 등장 이전
리스트를 인자로 받아 총합을 구하는 sum 메서드가 있다고 하자.<br>
제네릭이 존재하기 이전에는 다음과 같이 구현할 수 있었다.
```java
int sum(List list) {
    int sum = 0;
    for (int i = 0; i < list.size(); i++) {
        sum += Integer.parseInt(list.get(i));
    }
    return sum;
}
```
위 메서드는 잘못된 타입의 요소가 들어와도 컴파일 시점에는 오류가 발생하지 않고, 런타임에서 오류가 발생한다는 문제점이 있다.

이러한 문제를 해결하기 위해 **제네릭**이 등장했다.
  
## 제네릭 (Generic)
**제네릭**은 클래스나 메서드가 사용할 **타입을 매개변수화**하여, 코드 작성 시점에 타입을 지정할 수 있다.<br>
이를 통해, 컴파일 시점에 **타입 안정성**을 보장하고, 불필요한 형변환을 줄여 코드의 간결성과 가독성을 높여준다.

제네릭을 사용해서 sum 메서드를 다음과 같이 수정할 수 있다.
```java
int sum(List<Integer> list) {
    int sum = 0;
    for (Integer e : list) {
        sum += e;
    }
    return sum;
}
```

### 제네릭은 불공변
제네릭은 기본적으로 **불공변**이다.<br>
`String`은 `Object`의 하위 타입이지만, `List<String>`은 `List<Object>`의 하위 타입이 아니다.
```java
List<Object> objects = new ArrayList<String>(); // 컴파일 에러
```

이 때문에 상속 관계를 활용한 코드 작성이 어려워졌다.<br>
리스트를 인자로 받아 순회해서 출력해 주는 print 메서드가 있다고 하자.
```java
void print(List<Object> list) {
    for (Object e : list) {
        System.out.println(e);
    }
}
```
위 메서드는 `List<Object>`만 받을 수 있다. 하지만 `List<String>`이나 `List<Integer>`도 충분히 처리 할 수 있어야 한다.

이러한 상황을 위해 **와일드카드**를 제공한다.

## 와일드카드 (Wildcards)
**와일드카드**는 제네릭 코드에서 `?`로 표기된다. **정해지지 않은 타입**(unknown type)이기 때문에 **모든 타입을 대신**할 수 있다.<br>
이를 통해, 타입을 알 수 없는 상황에서 코드의 **재사용성**과 **유연성**을 높여준다.

와일드 카드를 사용해서 print 메서드를 다음과 같이 수정할 수 있다.
```java
void print(List<?> list) {
    for (Object e : alist) {
        System.out.println(e);
    }
}
```

## 한정적 와일드카드 (Bounded Wildcards)
한정적 와일드카드는 특정 타입을 기준으로 상한 범위와 하한 범위를 지정하여, 제네릭 타입 인자로 허용되는 범위를 제한할 수 있다.

### 비한정적 와일드카드
컴파일러는 `<?>`가 어떤 타입인지 모르기 때문에 안전하게 보장할 수 있는 연산만 허용한다.
```java
List<?> list = List.of("a", "b", "c");

Object o = list.get(0); // Object로만 읽을 수 있다.

list.add("hello"); // 컴파일 에러
list.add(123); // 컴파일 에러
list.add(null);
```

### 상한경계 와일드카드
`<? extends T>`으로 상한 범위를 지정할 수 있다.
`<? extends Number>`은 `Number` 또는 그 하위 타입만 허용한다.
```java
List<? extends Number> list = new ArrayList<Integer>(); // 공변처럼 동작
Number n = list.get(0); // 꺼내기 가능
list.add(10); // 추가 불가능
```

### 하한경계 와일드카드
`<? super T>`으로 하한 범위를 지정할 수 있다.
`<? super Integer>`는 `Integer` 또는 그 상위 타입만 허용한다.
```java
List<? super Integer> list = new ArrayList<Number>(); // 불공변처럼 동작
list.add(10); // 추가 가능
Object obj = list.get(0); // Object 형으로 밖에 꺼내지 못함
```

### PECS (Producer-Extends, Consumer-Super)
매개변수화 타입 T가 생산자면 extends를 쓰고 소비자면 super를 사용하는 원칙이다.

- 데이터를 생산해서 꺼내는 컨테이너라면 `<? extends T>` (읽기)
- 데이터를 소비해서 집어넣는 컨테이너라면 `<? super T>` (쓰기)

```java
void copy(List<? extends Number> src, List<? super Number> dest) {
    for (Number n : src) {
        dest.add(n); // src는 읽기용, dest는 쓰기용
    }
}
```

---
**Reference**<br>
- https://ko.wikipedia.org/wiki/공변성과_반공변성_(컴퓨터_과학)
- https://mangkyu.tistory.com/241

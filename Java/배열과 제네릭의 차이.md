# 배열과 제네릭의 차이

## 공변(Covariant) / 불공변(Invariant)
### 배열은 공변
```java
Object[] objectArray = new String[10];
```
`String`는 `Object`의 하위 타입이다.<br>
배열은 공변이기 때문에 상속 관계가 그대로 유지된다. 즉, `String[]`는 `Object[]`의 하위 타입이 된다.<br>
따라서 상위타입인 `Object[]`에 하위 타입인 `String[]`를 할당할 수 있다.

```java
objectArray[0] = 1; // 런타임 오류 (ArrayStoreException)
```
하지만 이런 경우 문제가 생긴다.<br>
`objectArray`의 실제 타입은 `Integer[]`인데, 컴파일러는 이를 단순히 `Object[]`로 인식한다.<br>
그 결과, **런타임**에 실제 타입과 저장하려는 타입이 일치하지 않아 `ArrayStoreException`이 발생한다.

### 제네릭은 불공변
```java
List<Object> objectList = new ArrayList<String>(); // 컴파일 오류
```
`String`은 `Object`의 하위 타입이다.<br>
제네릭은 불공변이기 때문에 상속 관계가 그대로 유지되지 않는다. 즉, `List<String>`은 `List<Object>`의 하위 타입이 아니며 둘은 아무런 관계가 없다.<br>
따라서 위 코드는 **컴파일 타임**에 오류가 발생한다.

제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.

## 실체화(Reification) / 타입 소거(Type erasure)
### 배열 실체화
실체화란 타입 정보가 런타임까지 유지되는 것을 의미한다.

배열은 생성될 때 지정된 타입 정보를 런타임까지 가지고 있기 때문에,
런타임 시점에 배열에 잘못된 타입의 값을 저장하려 하면 `ArrayStoreException`이 발생한다.

### 제네릭 타입 소거
타입 소거란 컴파일 시 제네릭 타입의 타입 파라미터 정보를 제거하는 것을 의미한다.

제네릭 타입을 사용하여 컴파일 시점에 타입 안정성을 검증하고, 컴파일된 바이트 코드에서는 제네릭 타입 매개변수가 제거된다.
따라서 런타임에는 `List<String>`이나 `List<Integer>` 모두 `List` 타입으로 취급된다.
이는 JDK 5 이전 코드와의 호환성을 유지하기 위함이다.

## 요약
- **배열**: 공변, 실체화된 타입, 런타임 타입 검사
- **제네릭**: 불공변, 타입 소거, 컴파일 타입 검사

---
**Reference**
- https://velog.io/@enjoy89/이펙티브-자바-아이템-28-배열보다는-리스트를-사용하라

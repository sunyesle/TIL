# 인덱스 스캔 방식
## Index Range Scan
B*Tree 인덱스의 가장 정상적이고 일반적인 형태의 액세스 방식이다.
인덱스 루트에서 리프 블록까지 수직적으로 탐색한 후에 필요한 범위만 스캔한다.

Index Range Scan을 하려면 인덱스 선두 컬럼을 가공하지 않은 상태로 조건절에서 사용해야 한다.

인덱스를 탄다고 항상 성능이 좋아지는 것은 아니다.
성능은 인덱스 스캔 범위, 테이블 액세스 횟수를 얼마나 줄일 수 있느냐로 결정된다.

## Index Full Scan
수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.

대게 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택된다.

### Index Full Scan의 효용성
> 인덱스 선두 컬럼을 조건절에서 사용하지 않으면 옵티마이저는 기본적으로 Table Full Scan을 선택한다.<br>
> Table Full Scan보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있다면 Index Full Scan을 사용하기도 한다.

#### I/O를 줄일 수 있는 경우
대용량 테이블이어서 Table Full Scan에 따른 부담이 클 경우, 옵티마이저는 인덱스 활용을 고려하지 않을 수 없다.
만약 인덱스 스캔 단계에서 대부분의 레코드를 필터링하고 아주 일부만 테이블을 액세스하는 상황이라면 인덱스를 스캔하는 쪽이 유리하다.

하지만, 이 방식은 적절한 인덱스가 없어 Index Range Scan의 차선책으로 선택된 것이다.
수행 빈도가 높은 SQL이라면 적절한 인덱스를 생성해 주는것이 좋다.

#### 인덱스를 이용한 소트 연산 생략
인덱스를 Full Scan 하면 결과 집합이 인덱스 컬럼 순으로 정렬된다.
따라서 Sort Order By 연산을 생략할 목적으로 사용할 수도 있다.

부분 범위 처리가 가능한 상황에서 극적인 성능 개선 효과를 가져다준다.

## Index Unique Scan
수직적 탐색만으로 데이터를 찾는 스캔 방식이다.

Unique 인덱스를 '=' 조건으로 탐색하는 경우에 작동한다.

## Index Skip Scan
Index Skip Scan은 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스하는 방식이다.

인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용할 수 있다.
조건절에 빠진 인덱스 선두 컬럼의 Distinct Value 개수가 적고, 후행 컬럼의 Distinct Value 개수가 많을 때 유용하다.

> Distinct Value 개수: 특정 컬럼에서 unique한 값의 개수
> 예를 들어 고객 테이블에서 Distinct Value 개수가 적은 컬럼은 '성별', 많은 컬럼은 '고객번호'이다.

## Index Fast Full Scan
논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔한다.

디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과를 발휘한다.
속도는 빠르지만, 인덱스 리프 노드가 갖는 연결 리스트 구조를 무시한 채 데이터를 읽기 때문에 결과 집합이 인덱스 키 순서대로 정렬되지 않는다.
쿼리에 사용한 컬럼이 모두 인덱스에 포함되어 있을 때만 사용할 수 있다.

인덱스가 파티션되어있지 않더라도 병렬 쿼리가 가능하다.
병렬 쿼리 시에는 Direct Path I/O 방식을 사용하기 때문에 I/O 속도가 더 빨라진다.

## Index Range Scan Descending
Index Range Scan과 기본적으로 동일한 스캔 방식이다.
인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과 집합을 얻는다는 점만 다르다.

---
**Reference**<br>
- 친절한 SQL 튜닝 2장

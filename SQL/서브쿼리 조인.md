# 서브쿼리 조인

## 서브쿼리 종류
```sql
select c.고객번호, c.고객명, c.평균거래, t.최소거래, t.최대거래
     , (select 고객분류명 from 고객분류 where 고객분류코드 = c.고객분류코드) -- ★스칼라 서브쿼리
from 고객 c
    , (select 고객번호, avg(거래금액) 평균거래
            , min(거래금액) 최소금액, max(거래금액) 최대거래
       from 거래
       where 거래일시 >= turnc(sysdate, 'mm')
       group by 고객번호) t -- ★인라인 뷰
where c.가입일시 >= trunc(add_months(sysdate, -1), 'mm')
and t.고객번호 = c.고객번호
and exists (select 'x'
            from 고객변경이력 h
            and h.고객번호 = c.고객번호
            and h.변경사유코드 = 'ZCH'
            and c.최종변경일시 between h.시작일시 and h.종료일시) -- ★중첩된 서브쿼리
```

- **인라인 뷰**(Inline View): FROM 절에 사용한 서브쿼리를 말한다.
- **중첩된 서브쿼리**(Nested Subquery): 결과 집합을 한정하기 위해 WHERE 절에 사용한 서브쿼리를 말한다. 특히, 서브쿼리가 메인쿼리 컬럼을 참조하는 형태를 '상관관계 있는(Correlated) 서브쿼리'라고 부른다.
- **스칼라 서브쿼리**(Scalar Subquery): 한 레코드당 정확히 하나의 값을 반환하는 서브쿼리를 말한다. 주로 SELECT-LIST에서 사용한다.

## 서브쿼리와 조인
서브쿼리는 메인쿼리에 종속되므로 단독으로 실행할 수 없으며, 메인쿼리 건수만큼 값을 받아 반복적으로 필터링하는 방식으로 실행해야한다.

### 필터 오퍼레이션
`/*+ no_unnest */`

Unnesting 되지 않은 서브쿼리는 항상 필터 방식으로 처리되며, 대개 실행계획 상에서 맨 마지막 단계에 처리된다.

필터 오퍼레이션은 기본적으로 NL 조인과 처리 루틴이 같다. NL 조인과의 차이점은 다음과 같다.
- 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 진행을 멈추고, 메인쿼리의 다음 로우를 처리한다.
- 캐싱 기능을 갖는다.
- 조인 순서가 고정된다. 항상 메인쿼리가 드라이빙 집합이다.

### 서브쿼리 Unnesting
`/*+ unnest */`

서브쿼리 Unnesting은 중첩된 서브쿼리를 풀어내어 메인쿼리와 같은 레벨로 만들어준다.

필터 방식에서는 항상 메인쿼리가 드라이빙 집합이며, NL 조인 방식으로 처리된다.
하지만 Unnesting을 통해 메인쿼리와 같은 레벨로 만들면 다양한 조인 방식과 조인 순서를 선택할 수 있다.

### 서브쿼리 Pushing
`/*+ no_unnest push_subq */`

`push_subq`은 서브쿼리 필터링을 가능한 앞 단계에서 처리하도록 강제하는 기능이다.

Unnesting되지 않은 서브쿼리에서만 작동한다.
따라서 push_subq 힌트는 항상 no_unnest 힌트와 같이 기술하는 것이 올바른 사용법이다.

서브쿼리 필터 단계에서 많은 데이터를 거를 수 있다면, 서브쿼리 Pushing을 통해 성능을 향상시킬 수 있다.

반대로 서브쿼리 필터링을 가능한 한 나중에 처리하게 하려면 `no_push_subq`를 사용하면 된다.

### 뷰 Merging
`/* merge */`

인라인 뷰를 메인 쿼리와 병합하여 하나의 쿼리 블록으로 만드는 작업이다.

### 조건절 Pushing
`/*+ no_merge push_pred */`

바깥 조건절을 인라인 뷰 내부로 밀어넣어 조기 필터링을 유도하는 기능이다.

---
**Reference**<br>
- 친절한 SQL 튜닝 4장

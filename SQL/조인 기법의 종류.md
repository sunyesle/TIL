# 조인 기법의 종류

## NL 조인(Nested Loop Join)
- 중첩 루프문(Nested Loop)의 수행 구조를 사용한다.
- 양쪽 테이블의 **인덱스를 이용하는 조인 방식**이다.

### NL조인 매커니즘
- Outer 테이블을 순차적으로 읽어 조건을 만족하는 행을 Inner 테이블에서 탐색한다.
- 일반적으로 Outer(Driving)와 Inner 양쪽 테이블 모두 인덱스를 사용한다.

```sql
SELECT e.사원명, c.고객명, c.전화번호
FROM 사원 e, 고객 c
WHERE e.입사일자 >= '19960101'
AND c.관리사원번호 = e.사원번호
```

1. 사원 인덱스에서 조건에 맞는 첫 번째 레코드를 찾는다.
2. 인덱스에서 읽은 ROWID로 사원 테이블 레코드를 찾는다.
3. 사원 테이블에서 읽은 사원번호로 고객 인덱스를 탐색한다.
4. 고객 인덱스에서 읽은 ROWID로 고객 테이블 레코드를 찾는다.
5. 사원 인덱스에서 입사일자 >= '19960101' 인 모든 레코드에 대해 (1)~(4) 과정을 반복한다.

> 실행계획

<img src="https://github.com/user-attachments/assets/da9f9008-18a3-4211-938a-eb1d66a9b1c0" width="600"/>

### NL조인 특징
- 랜덤 액세스 위주의 조인 방식이다. 대량 데이터 조회에 불리하다.
- 한 레코드씩 순차적으로 진행한다. 부분범위 처리가 가능한 상황에서 매우 빠른 응답 속도를 낼 수 있다.
- 인덱스 구성 전략이 중요하다.

> NL 조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 OLTP 시스템에 적합한 조인 방식이다.

## 소트 머지 조인(Sort Merge Join)
- 조인 컬럼을 기준으로 데이터를 정렬하여 조인을 수행한다.
- 주로 스캔 방식으로 데이터를 읽는다. 조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인일 때 유용하다.
- 해시 조인을 사용할 수 없는 비동등 조인에 대해서도 조인 작업이 가능하다.

### 소트 머지 조인 매커니즘
- 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
- 머지 단계: 정렬한 양쪽 집합을 서로 머지한다.

```sql
SELECT /*+ ordered use_merge(c) */
    e.사원번호, e.사원명, e.입사일자, c.고객명, c.전화번호
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'
AND e.부서코드 = 'Z123'
AND c.최종주문금액 >= 20000
```

1. 사원 데이터를 읽어 조인컬럼인 사원번호순으로 정렬하여, PGA 영역에 할당된 Sort Area에 저장한다.
2. 고객 데이터를 읽어 조인컬럼인 관리사원번호순으로 정렬하여, PGA 영역에 할당된 Sort Area에 저장한다.
3. PGA에 저장한 사원 데이터를 스캔하면서 PGA에 저장된 고객 데이터와 조인한다.
   - 고객 데이터가 정렬되어 있기 때문에, 사원 데이터를 기준으로 고객 데이터를 매번 Full Scan 하지 않는다.

> 실행계획

<img src="https://github.com/user-attachments/assets/2efd2e07-6f25-441f-8d4f-1b9dead87a8d" width="600"/>

### 소트 머지 조인 특징
- 양쪽 테이블로부터 조인 대상 집합을 일괄적으로 읽어 PGA에 저장한 후 조인한다. 소트 부하만 감수한다면 건건이 버퍼캐시를 경유하는 NL 조인보다 빠르다.
- 조인 컬럼에 대한 인덱스 유무에 영향을 받지 않는다.
- 스캔 위주의 액세스 방식을 사용한다.

> 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인에서 적합한 조인 방식이다.

## 해시 조인(Hash Join)
- 주로 스캔 방식으로 데이터를 읽는다. 조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인일 때 유용하다.
- 소트 머지 조인은 항상 양쪽 테이블을 정렬하는 부담이 있지만, 해시 조인은 그런 부담이 없다.

### 해시 조인 매커니즘
- Build 단계: 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성한다.
- Probe 단계: 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인한다.

```sql
SELECT /*+ ordered use_hash(c) */
    e.사원번호, e.사원명, e.입사일자, c.고객명, c.전화번호
FROM 사원 e, 고객 c
WHERE c.관리사원번호 = e.사원번호
AND e.입사일자 >= '19960101'
AND e.부서코드 = 'Z123'
AND c.최종주문금액 >= 20000
```

1. 조건에 맞는 사원 데이터를 읽어 조인 컬럼인 사원번호를 해시 테이블 키값으로 해시 테이블을 생성한다. 사원번호를 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인에 데이터를 연결한다. 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장한다.
2. 조건에 맞는 고객 데이터를 하나씩 읽어 앞서 생성한 해시 테이블을 탐색한다. 해시 함수가 반환한 값에 해당하는 해시 체인만 스캔하면 된다.

> 실행계획

<img src="https://github.com/user-attachments/assets/fd505bab-97e2-46b9-ac5f-1e98d3edb45b" width="600"/>

### 해시 조인 특징
- 해시 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인에서만 사용 가능하다.
- 둘 중 하나의 테이블을 읽어 해시 맵을 만들고 PGA에 저장한 후 조인한다.
- 조인 컬럼에 대한 인덱스 유무에 영향을 받지 않는다.
- 스캔 위주의 액세스 방식을 사용한다.

## 조인 메서드 선택 기준

<img src="https://github.com/user-attachments/assets/bc577896-b7d0-442a-8b88-fdc1caa5e86e" width="600"/>

### 일반적인 선택 기준
- **소량 데이터를 조인할 때 -> NL 조인**
- **대량 데이터를 조인할 때 -> 해시 조인**
- **대량 데이터 조인인데 조인 조건식이 등치(=) 조건이 아닐 때(카테시안 곱 포함) -> 소트 머지 조인**

NL 조인 기준으로 최적화했는데도 랜덤 액세스가 많아 만족할 만한 성능을 낼 수 없다면, 대량 데이터 조인에 해당한다.

### 수행 빈도가 매우 높은 쿼리에서 선택 기준
- **최적화된 NL 조인과 해시 조인의 성능이 비슷하면 -> NL 조인**
- **NL 조인보다 해시 조인이 매우 빠른 경우 -> 해시 조인**

NL 조인에 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조다.
반면, 해시 테이블은 **단 하나의 쿼리를 위해 생성하고 조인이 끝나면 소멸하는 자료구조**다.

수행 빈도가 높은 쿼리를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가한다.

해시 조인은 수행 빈도가 낮고, 쿼리 수행 시간이 오래 걸리고, 대량 데이터 조인인 경우에 주로 사용한다.

---
**Reference**<br>
- 친절한 SQL 튜닝 4장
- https://minnseong.tistory.com/48
- https://velog.io/@eunhye_/SQL-%EC%A1%B0%EC%9D%B8Join-%EC%88%98%ED%96%89-%EC%9B%90%EB%A6%AC

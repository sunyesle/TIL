# 소트 튜닝 - 인덱스를 이용한 소트 연산 생략
인덱스는 항상 정렬된 상태를 유지한다.
이를 활용하면 SQL에 Order By 또는 Group By 절이 있어도 소트 연산을 생략할 수 있다.

여기에 Top N 쿼리 특성을 결합하면 온라인 트랜잭션 시스템에서 대량 데이터를 조회할 때 매우 빠른 응답 속도를 낼 수 있다.

## Sort Order By 생략
아래 쿼리에서 인덱스 선두 컬럼을 [`종목코드 + 거래일시`] 순으로 구성하면 소트 연산을 생략할 수 있다.
```sql
select 거래일시, 체결건수, 체결수량, 거래대금
from   종목거래
where  종목코드 = 'KR123456'
order by 거래일시
```

**소트 연산을 생략**함으로써 종목코드 'KR123456' 조건을 만족하는 전체 레코드를 읽지 않고도 바로 결과집합 출력을 시작할 수 있게 되었다.

즉, **부분범위 처리가 가능**한 상태가 되었다.
이 원리를 활용하면, 소트해야될 대상 레코드가 많은 상황에서 극적인 성능 개선 효과를 얻을 수 있다.

### 부분범위 처리를 활용한 튜닝 기법
부분범위 처리는 쿼리 수행 결과 중 앞쪽 일부를 우선 전송하고 클라이언트가 추가 전송을 요청할 때마다 남은 데이터를 조금씩 나눠 전송하는 방식을 말한다.

토드, DBeaver와 같이 클라이언트 프로그램이 DB서버에 직접 접속하는 2-Tier 환경에서는 이 특징을 활용한 튜닝기법을 많이 활용했다.

클라이언트와 DB 서버 사이에 WAS 서버등이 존재하는 3-Tier 아키텍쳐는 서버 리소스를 수많은 클라이언트가 공유하는 구조이므로 클라이언트가 특정 DB 커넥션을 독점할 수 없다.
단위 작업을 마치면 DB 커넥션을 바로 커넥션 풀에 반해야하므로 그 전에 결과를 클라이언트에게 모두 전송하고 커서를 닫아야만 한다.
따라서 쿼리 결과를 나눠서 전송하는 방식을 사용할 수 없다.

하지만 부분범위 처리 원리는 3-Tier 환경에서도 여전히 유효한데 이유는 Top N 쿼리에 있다.

## Top N 쿼리
Top N 쿼리는 **전체 결과집합 중 상위 N개의 레코드만 선택**하는 쿼리이다.

오라클에서는 아래와 같이 인라인 뷰로 한 번 감싸서 Top N 쿼리를 작성할 수 있다.
```sql
select * from (
  select 거래일시, 체결건수, 체결수량, 거래대금
  from   종목거래
  where  종목코드 = 'KR123456'
  order by 거래일시
)
where rownum <= 10

Execution Plan
-----------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS
  COUNT (STOPKEY)
    VIEW
      TABLE ACCESS (BY INDEX ROWID) OF '종목거래' (TABLE)
        INDEX (RANGE SCAN) OF '종목거래_PK' (INDEX (UNIQUE))
```
위 쿼리에서 [`종목코드 + 거래일시`] 순으로 구성된 인덱스를 이용하면, 옵티마이저는 소트 연산을 생략하며, 인덱스를 스캔하다가 10개의 레코드를 읽는 순간 멈춘다.

실행계획을 보면 Sort Order By 오퍼레이션이 보이지 않는다. 대신 `COUNT (STOPKEY)`가 눈에 띈다.
이는 조건절에 부합하는 레코드가 많아도 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다는 뜻이다.

지금부터 이 기능을 **Top N Stopkey** 알고리즘이라고 부르기로 하자.

### 페이징 처리
페이징 처리 시 Top N 쿼리를 활용할 수 있다. 일반적으로 사용하는 페이징 처리용 표준 패턴은 다음과 같다.
```sql
select *
from (
     select rownum no, a.*
     from (
         /* SQL Body */
     )
     where rownum <= (:page * 10)
)
where no >= (:page-1)*10 + 1
```
부분범위 처리 가능하도록 SQL을 작성하여 SQL Body 부분에 넣는다.

> **부분범위 처리 가능하도록 SQL 작성하기**<br>
> - 인덱스 사용 가능하도록 조건절을 구사
> - NL조인 위주로 처리 (룩업을 위한 작은 테이블은 해시 조인 Build Input으로 처리해도 된다.)
> - Order By 절이 있어도 소트 연산을 생략할 수 있도록 인덱스 구성

### 페이징 처리 ANTI 패턴
만약 다음과 같이 Order By 아래쪽 ROWNUM 조건절을 제거하는 경우 Top N Stopkey 알고리즘이 작동하지 않으니 주의하자.
```sql
select *
from (
     select rownum no, a.*
     from (
          /* SQL Body */
     )
)
where no between (:page-1)*10 + 1 and (:page * 10)
``` 

## 최소값/최대값 구하기
최소값(MIN) 또는 최대값(MAX)을 구하는 SQL 실행계획을 보면 Sort Aggregate 오퍼레이션이 나타난다.
Sort Aggregate를 위해 전체 데이터를 읽으면서 값을 비교하게 된다.
```sql
SELECT MAX(SAL) FROM EMP;

Execution Plan
-----------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS
  SORT (AGGREGATE)
    TABLE ACCESS (FULL) OF 'EMP' (TABLE)
```

인덱스는 정렬되어있으므로 이를 이용하면 전체 데이터를 읽지 않고도 최소/최대값을 찾을 수 있다.
```sql
CREATE INDEX EMP_X1 ON EMP(SAL);

SELECT MAX(SAL) FROM EMP;

Execution Plan
-----------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS
  SORT (AGGREGATE)
    INDEX (FULL SCAN (MIN/MAX)) OF 'EMP_X1' (INDEX)
```

### 인덱스를 이용해 최소/최대값을 구하기 위한 조건
인덱스를 이용해 최소/최대값을 구하려면 **조건절 컬럼**과 **MIN/MAX 함수 인자 컬럼**이 모두 **인덱스에 포함**되어 있어야 한다.
즉, 테이블 액세스가 발생하지 않아야 한다.

◆ **인덱스를 [`DEPTNO + MGR + SAL`] 순으로 구성한 경우**<br>
```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, MGR, SAL);

SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;

Execution Plan
-----------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS
  SORT (AGGREGATE)
    FIRST ROW
      INDEX (RNAGE SCAN (MIN/MAX)) OF 'EMP_X1' (INDEX)
```
조건절과 MAX 컬럼이 모두 인덱스에 포함되어 있고, 인덱스 선두 컬럼 DEPTNO, MGR이 모두 `=` 조건이므로 두 조건을 만족하는 범위(Range) 가장 오른쪽에 있는 값 하나를 읽는다.
DEPTNO와 MGR는 모두 액세스 조건이다.

이를 **First Row Stopkey** 알고리즘이라고 부르기로 하자.

◆ **인덱스를 [`DEPTNO + SAL + MGR`] 순으로 구성한 경우**

DEPTNO 조건을 만족하는 범위(Range) 가장 오른쪽으로 내려가고, 거기서부터 스캔을 시작해 MGR 조건을 만족하는 레코드를 하나 찾았을 때 멈추게 된다.
DEPTNO는 액세스 조건, MGR는 필터 조건이다.

◆ **인덱스를 [`SAL + DEPTNO + MGR`] 순으로 구성한 경우**

조건절 컬럼이 모두 인덱스 선두 컬럼이 아니므로 Index Range Scan은 불가능하다.
Index Full Scan 방식으로 인덱스 전체 레코드 중 가장 오른쪽에서 스캔을 시작해 DEPTNO와 MGR조건을 모두 만족하는 레코드를 하나 찾았을 때 멈추게 된다.
DEPTNO와 MGR는 모두 필터 조건이다.

◆ **인덱스를 [`DEPTNO + SAL`] 순으로 구성한 경우**

```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL);

SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;

Execution Plan
-----------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS
  SORT (AGGREGATE)
    TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)
      INDEX (RNAGE SCAN) OF 'EMP_X1' (INDEX)
```
First Row Stopkey 알고리즘이 작동하지 않는다.
인덱스에서 DEPTNO 조건을 만족하는 '전체' 레코드를 읽어 테이블에서 MGR 조건을 필터링한 후 MAX(SAL) 값을 구한다.

### Top N 쿼리를 이용해 최소/최대값 구하기
Top N 쿼리에 작동하는 **Top N Stopkey** 알고리즘은 **모든 컬럼이 인덱스에 포함되어 있지 않아도 작동**한다.

인라인 뷰를 사용하므로 쿼리가 약간 더 복잡하지만, 성능 측면에서는 MIN/MAX 쿼리보다 낫다.
```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL);

SELECT *
FROM ( 
     SELECT SAL
     FROM EMP
     WHERE DEPTNO = 30
     AND MGR = 7698
     ORDER BY SAL DESC
)
WHERE ROWNUM <= 1;

Execution Plan
-----------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS
  COUNT (STOPKEY)
    VIEW
     TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)
      INDEX (RNAGE SCAN DESCENDING) OF 'EMP_X1' (INDEX)
```
DEPTNO 조건을 만족하는 가장 오른쪽에서부터 역순으로 스캔하면서 테이블을 액세스하다가 MGR 조건을 만족하는 레코드 하나를 찾았을 때 바로 멈춘다.


---
**Reference**<br>
- 친절한 SQL 튜닝 5장

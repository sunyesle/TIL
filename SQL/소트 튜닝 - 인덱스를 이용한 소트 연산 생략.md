# 소트 튜닝 - 인덱스를 이용한 소트 연산 생략
인덱스는 항상 정렬된 상태를 유지한다.
이를 활용하면 SQL에 Order By 또는 Group By 절이 있어도 소트 연산을 생략할 수 있다.

여기에 Top N 쿼리 특성을 결합하면 온라인 트랜잭션 시스템에서 대량 데이터를 조회할 때 매우 빠른 응답 속도를 낼 수 있다.

## Sort Order By 생략
아래 쿼리에서 인덱스 선두 컬럼을 [종목코드 + 거래일시] 순으로 구성하면 소트 연산을 생략할 수 있다.
```sql
select 거래일시, 체결건수, 체결수량, 거래대금
from   종목거래
where  종목코드 = 'KR123456'
order by 거래일시
```

**소트 연산을 생략**함으로써 종목코드 'KR123456' 조건을 만족하는 전체 레코드를 읽지 않고도 바로 결과집합 출력을 시작할 수 있게 되었다.

즉, **부분범위 처리가 가능**한 상태가 되었다.
이 원리를 활용하면, 소트해야될 대상 레코드가 많은 상황에서 극적인 성능 개선 효과를 얻을 수 있다.

### 부분범위 처리를 활용한 튜닝 기법
부분범위 처리는 쿼리 수행 결과 중 앞쪽 일부를 우선 전송하고 클라이언트가 추가 전송을 요청할 때마다 남은 데이터를 조금씩 나눠 전송하는 방식을 말한다.

토드, DBeaver와 같이 클라이언트 프로그램이 DB서버에 직접 접속하는 2-Tier 환경에서는 이 특징을 활용한 튜닝기법을 많이 활용했다.

클라이언트와 DB 서버 사이에 WAS 서버등이 존재하는 3-Tier 아키텍쳐는 서버 리소스를 수많은 클라이언트가 공유하는 구조이므로 클라이언트가 특정 DB 커넥션을 독점할 수 없다.
단위 작업을 마치면 DB 커넥션을 바로 커넥션 풀에 반해야하므로 그 전에 결과를 클라이언트에게 모두 전송하고 커서를 닫아야만 한다.
따라서 쿼리 결과를 나눠서 전송하는 방식을 사용할 수 없다.

하지만 부분범위 처리 원리는 3-Tier 환경에서도 여전히 유효한데 이유는 Top N 쿼리에 있다.

## Top N 쿼리
Top N 쿼리는 **전체 결과집합 중 상위 N개의 레코드만 선택**하는 쿼리이다.

오라클에서는 아래와 같이 인라인 뷰로 한 번 감싸서 Top N 쿼리를 작성할 수 있다.
```sql
select * from (
  select 거래일시, 체결건수, 체결수량, 거래대금
  from   종목거래
  where  종목코드 = 'KR123456'
  order by 거래일시
)
where rownum <= 10

Execution Plan
-----------------------------------------------------
SELECT STATEMENT Optimizer=ALL_ROWS
  COUNT (STOPKEY)
    VIEW
      TABLE ACCESS (BY INDEX ROWID) OF '종목거래' (TABLE)
        INDEX (RANGE SCAN) OF '종목거래_PK' (INDEX (UNIQUE))
```
위 쿼리에서 [종목코드 + 거래일시] 순으로 구성된 인덱스를 이용하면, 옵티마이저는 소트 연산을 생략하며, 인덱스를 스캔하다가 10개의 레코드를 읽는 순간 멈춘다.

실행계획을 보면 Sort Order By 오퍼레이션이 보이지 않는다. 대신 `COUNT (STOPKEY)`가 눈에 띈다.
이는 조건절에 부합하는 레코드가 많아도 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다는 뜻이다.

지금부터 이 기능을 **Top N Stopkey** 알고리즘이라고 부르기로 하자.

---
**Reference**<br>
- 친절한 SQL 튜닝 5장

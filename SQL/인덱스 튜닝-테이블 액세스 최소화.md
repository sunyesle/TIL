# 테이블 액세스 최소화
SQL 튜닝에 있어 랜덤 I/O는 매우 중요하다. SQL 성능 향상을 위해 DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됐고, 많은 튜닝 기법도 **랜덤 I/O 최소화**에 맞춰져 있다.

## 테이블 랜덤 액세스
인덱스를 이용해 테이블을 액세스하는 경우, SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 게 아니라면 인덱스를 스캔한 후 반드시 테이블을 액세스한다. 실행 계획에서 `TABLE ACCESS BY INDEX ROWID`가 여기에 해당한다.

**인덱스를 스캔하는 이유**는 검색 조건을 만족하는 **소량의 데이터를 인덱스에서 빠르게 찾고**, 테이블 레코드를 찾아가기 위한 주소값 즉 **ROWID를 얻으려는 데 있다**.

### ROWID
ROWID는 테이블의 각 행의 대한 고유 식별자로 디스크 상에서 테이블 레코드를 찾아가기 위한 논리적 주소 정보이다.

ROWID는 데이터 파일 번호, 데이터 블록 번호, 블록 내의 행 번호로 구성되어 있다.

ROWID가 가리키는 테이블 블록은 버퍼 캐시에서 찾아보고, 찾지 못했을 경우 디스크에서 읽어와서 버퍼 캐시에 적재한 후 블록을 읽는다.

이처럼 **ROWID를 이용한 테이블 액세스**는 생각보다 **고비용 연산**이다.

## 인덱스 클러스터링 팩터
클러스터링 팩터(Clustering Factor, CF)는 인덱스를 기준으로 테이블 데이터가 얼마나 모여있는지를 나타내는 지표이다.

CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋다.
버퍼 캐시 히트률이 증가하여 테이블 액세스량에 블록 I/O가 적게 발생함을 의미한다.

다음은 CF가 좋은 상태와 안 좋은 상태를 도식화한 그림이다.

![Clustering Factor](https://github.com/user-attachments/assets/bbce3a8d-dca8-4c37-9091-b5bcb0bd57a7)

## 인덱스 손익분기점
인덱스 ROWID를 이용한 테이블 액세스는 고비용 연산이다.<br>
따라서 **읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다.**

Table Range Scan에 의한 액세스가 Table Full Scan보다 느려지는 지점을 흔히 인덱스 손익분기점이라고 부른다.

인덱스를 이용한 테이블 액세스가 Table Full Scan보다 더 느려지게 만드는 핵심적인 요인은 다음과 같다.
- Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
- Table Full Scan은 Multi Block I/O 인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식이다.

이런 요인에 의해 인덱스 손익분기점은 보통 5~20%의 낮은 수준에서 결정된다.
또한 CF에 따라 크게 달라진다. 1,000만 건 수준의 큰 테이블에서는 손익분기점이 더 낮아진다.

테이블 스캔이 항상 나쁜 것은 아니며, 바꿔 말해 인덱스 스캔이 항상 좋은 것도 아니다.<br>
소량의 데이터를 읽고 갱신하는 경우 인덱스를 효과적으로 활용하는 것이 중요하다.
반면, 대량의 데이터를 읽고 갱신하는 경우 전체 범위 처리 기준으로 튜닝해야 한다.

---
**Reference**<br>
- 친절한 SQL 튜닝 3장

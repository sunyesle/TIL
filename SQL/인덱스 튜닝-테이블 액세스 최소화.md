# 테이블 액세스 최소화
SQL 튜닝에 있어 랜덤 I/O는 매우 중요하다. SQL 성능 향상을 위해 DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됐고, 많은 튜닝 기법도 **랜덤 I/O 최소화**에 맞춰져 있다.

## 테이블 랜덤 액세스
인덱스를 이용해 테이블을 액세스하는 경우, SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 게 아니라면 인덱스를 스캔한 후 반드시 테이블을 액세스한다. 실행 계획에서 `TABLE ACCESS BY INDEX ROWID`가 여기에 해당한다.

**인덱스를 스캔하는 이유**는 검색 조건을 만족하는 **소량의 데이터를 인덱스에서 빠르게 찾고**, 테이블 레코드를 찾아가기 위한 주소값 즉 **ROWID를 얻으려는 데 있다**.

### ROWID
ROWID는 테이블의 각 행의 대한 고유 식별자로 디스크 상에서 테이블 레코드를 찾아가기 위한 논리적 주소 정보이다.

ROWID는 데이터 파일 번호, 데이터 블록 번호, 블록 내의 행 번호로 구성되어 있다.

ROWID가 가리키는 테이블 블록은 버퍼 캐시에서 찾아보고, 찾지 못했을 경우 디스크에서 읽어와서 버퍼 캐시에 적재한 후 블록을 읽는다.

이처럼 **ROWID를 이용한 테이블 액세스**는 생각보다 **고비용 연산**이다.

## 인덱스 클러스터링 팩터
클러스터링 팩터(Clustering Factor, CF)는 인덱스를 기준으로 테이블 데이터가 얼마나 모여있는지를 나타내는 지표이다.

CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋다.
버퍼 캐시 히트률이 증가하여 테이블 액세스량에 블록 I/O가 적게 발생함을 의미한다.

다음은 CF가 좋은 상태와 안 좋은 상태를 도식화한 그림이다.

![Clustering Factor](https://github.com/user-attachments/assets/bbce3a8d-dca8-4c37-9091-b5bcb0bd57a7)

## 인덱스 손익분기점
인덱스 ROWID를 이용한 테이블 액세스는 고비용 연산이다.<br>
따라서 **읽어야 할 데이터가 일정량을 넘는 순간, 테이블 전체를 스캔하는 것보다 오히려 느려진다.**

Table Range Scan에 의한 액세스가 Table Full Scan보다 느려지는 지점을 흔히 인덱스 손익분기점이라고 부른다.

인덱스를 이용한 테이블 액세스가 Table Full Scan보다 더 느려지게 만드는 핵심적인 요인은 다음과 같다.
- Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식이다.
- Table Full Scan은 Multi Block I/O 인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식이다.

이런 요인에 의해 인덱스 손익분기점은 보통 5~20%의 낮은 수준에서 결정된다.
또한 CF에 따라 크게 달라진다. 1,000만 건 수준의 큰 테이블에서는 손익분기점이 더 낮아진다.

테이블 스캔이 항상 나쁜 것은 아니며, 바꿔 말해 인덱스 스캔이 항상 좋은 것도 아니다.<br>
소량의 데이터를 읽고 갱신하는 경우 인덱스를 효과적으로 활용하는 것이 중요하다.
반면, 대량의 데이터를 읽고 갱신하는 경우 전체 범위 처리 기준으로 튜닝해야 한다.

## 인덱스 컬럼 추가
테이블 액세스를 최소화하기 위해 가장 일반적으로 사용하는 튜닝 기법은 **인덱스에 컬럼을 추가**하는 것이다.

EMP 테이블에 [DEPTNO + JOB] 순으로 구성한 EMP_X01 인덱스가 존재한다.
```sql
select /*+ index(emp emp_x01) */
from emp
where deptno
and sel >= 2000
```
실 운영 환경에서는 기존 인덱스를 활용하는 SQL이 존재할 수 있기 때문에 인덱스 구성을 변경하기 쉽지 않다.
그렇다고 매번 인덱스를 추가하다 보면 인덱스 관리 비용이 증가함은 물론 DML 부하에 따른 트랜잭션 성능 저하가 생길 수 있다.

이럴 때, 기존 인덱스에 SEL 컬럼을 추가하는 것만으로도 큰 효과를 얻을 수 있다. [DEPTNO + JOB + SEL]
인덱스 스캔량은 줄지 않지만, 테이블 랜덤 액세스 횟수를 줄여주기 때문이다.

## 인덱스만 읽고 처리
테이블 액세스 단계에서 필터 조건에 의해 버려지는 데이터가 없더라도, 스캔 과정에서 얻은 데이터가 많다면 그만큼 테이블 랜덤 액세스가 많이 발생하므로 성능이 느릴 수밖에 없다.

쿼리나 인덱스의 문제가 아니라 절대 일 량이 많아서 느린 거니 어쩔 수 없다.

반드시 성능을 개선해야 한다면, **쿼리에 사용된 컬럼을 모두 인덱스에 추가**해서 테이블 액세스가 아예 발생하지 않게 하는 방법을 고려해 볼 수 있다.
효과는 매우 좋지만, 추가해야 할 컬럼이 많아 실제 적용하기 곤란한 경우도 많다.

### 커버링 인덱스(Covering Index)
인덱스 키 외에 미리 **지정한 컬럼**을 **리프 블록에 함께 저장**하는 기능이다.
브랜치 블록에는 저장하지 않기 때문에 수직적 탐색에는 필터 조건으로 사용할 수 없다.

커버링 인덱스는 순전히 테이블 랜덤 액세스를 줄이는 용도로 개발되었다.

## 인덱스 구조 테이블
인덱스 구조로 생성된 테이블로 오라클은 IOT(Index-Organized Table)' MS-SQL Sever는 '클러스터형(Clustered) 인덱스'라고 부른다.

IOT는 테이블을 찾아가기 위한 ROWID를 갖는 일반 인덱스와 달리 그 자리에 테이블 데이터를 갖는다.<br>
즉, 테이블 블록에 있어야 할 데이터를 인덱스 **리프 블록에 모두 저장**하고 있다.

```sql
create table index_org_t ( a number, b varchar(10)
                         , constraint index_org_t_pk primary key (a) )
organization index;
```

> 참고로, 일반 테이블은 **힙 구조 테이블**이라고 부른다. 테이블을 생성할 때 대게 생략하지만, `organization heap` 옵션을 명시할 수도 있다.

IOT는 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나이다. 100% 정렬된 상태로 모여있으므로 시퀀셜 방식으로 데이터를 액세스한다.<br>
이 때문에 BETWEEN이나 부등호 조건으로 **넓은 범위를 읽을 때** 유리하다.

**데이터 입력과 조회 패턴이 서로 다른 테이블**에서도 유용하다.<br>
예를 들어, 어떤 회사에 영업사원이 100명이라고 가정하자. 영업사원들의 일별 실적을 집계하는 테이블이 있는데 한 블록에 100개의 레코드가 담긴다. 실적 등록은 일자별로 진행되지만, 실적 조회는 사원별로 이루어진다.
특정 사원의 1년 치 실적을 조회할 때 인덱스를 사용한다면 랜덤 액세스 방식으로 365개의 블록을 읽어야 한다.
사번이 첫 번째 정렬 기준이 되도록 IOT를 구성해주면 4개의 블록만 읽고 처리할 수 있다.

## 클러스터 테이블
### 인덱스 클러스터 테이블
**클러스터 키 값**이 같은 레코드를 **한 블록에 모아서 저장**하는 구조이다.

클러스터 인덱스도 일반 B*Tree 인덱스 구조를 사용하지만, 테이블 레코드를 일일이 가리키지 않고 해당 키값을 저장하는 첫 번째 테이블 블록을 가리킨다는 점이 다르다.

이러한 구조의 특성 때문에 클러스터 인덱스를 스캔하면서 값을 찾을 때는 랜덤 액세스가(클러스터 체인을 스캔하면서 발생하는 랜덤 액세스는 제외하고) 값 하나당 한 번밖에 발생하지 않는다.
클러스터에 도달해서는 시퀀셜 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없다는 게 핵심 원리다.

여러 테이블 레코드를 같은 블록에 저장할 수도 있는데, 이를 '다중 테이블 클러스터'라고 한다.

인덱스 클러스터 테이블 구성 방법은 다음과 같다.
클러스터를 생성한다.
```sql
create cluster c_dept# ( deptno number(2) ) index;
```

클러스터 인덱스를 정의한다.
```sql
crate index c_dept#_idx on cluster c_dept#;
```

클러스터 테이블을 생성한다.
```sql
create table dept (
  deptno number(2) not null
, dname varchar2(14) not null
, loc varchar2(13) )
cluster c_dept#( deptno );
```

### 해시 클러스터 테이블
해시 클러스터는 인덱스를 사용하지 않고 **해시 알고리즘**을 사용해 클러스터를 찾아간다는 점만 다르다.

해시 클러스터 테이블 구성 방법은 다음과 같다.

클러스터를 생성한다.
```sql
create cluster c_dept# ( deptno number(2) ) hashkeys 4;
```

클러스터 테이블을 생성한다.
```sql
create table dept (
  deptno number(2) not null
, dname varchar2(14) not null
, loc varchar2(13) )
cluster c_dept#( deptno );
```

---
**Reference**<br>
- 친절한 SQL 튜닝 3장
